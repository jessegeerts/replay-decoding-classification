# -*- coding: utf-8 -*-

import numpy as np

import json
from collections import namedtuple

try:
    from pandas import (Series as pd_Series, DataFrame as pd_DataFrame)
except ImportError:
    class pd_Series():
        pass # dummy
    class pd_DataFrame():
        pass
    
VarInfo = namedtuple('VarInfo',['name','type','dtype','shape','children','ma_fillvalue'])       

def restore_from_info_from_loadmat_recursive(y, info_str):
    """
    See make_info_for_savemat_recursive. 
    This function takes the string generated by that other function and a dict of
    entries that were passed in to that other function but then mangled by
    savemat/loadmat.  it uses the info string to reverse the mangling.
    """
    def recurse(x, xinfo):
        if not isinstance(xinfo, list):
            return x
        xinfo = VarInfo(*xinfo)
        if xinfo.type == "list":
            return [recurse(xx, xxinfo) if xxinfo else np.asscalar(xx)
                    for xx, xxinfo in zip(x.ravel(), xinfo.children)]
        elif xinfo.type == "tuple":
            return tuple(recurse(xx, xxinfo) if xxinfo else np.asscalar(xx)
                         for xx, xxinfo in zip(x.ravel(), xinfo.children))
        elif xinfo.type == "nd_array":
            # TODO: consider fortran/C problems when reshaping
            if np.dtype(xinfo.dtype).kind.lower() == "o" and xinfo.children is not None:
                ret = np.array([recurse(xx, xxinfo) if xxinfo else np.asscalar(xx)
                                 for xx, xxinfo in zip(x.flat, xinfo.children)])
            else:
                if x.dtype.kind.lower() == "o" and xinfo.children is None:
                    ret = np.hstack(tuple(np.asscalar(xx) for xx in x.flat)).astype(xinfo.dtype)
                else:
                    ret = x.astype(xinfo.dtype)
            ret = ret.reshape(xinfo.shape)
            if xinfo.ma_fillvalue:
                ret = np.ma.array(ret, mask=ret==xinfo.ma_fillvalue)
            return ret
        else:
            raise NotImplementedError("what should I do with type=" + xinfo.type)
            
    ret = {}
    for nm, item_info in json.loads(info_str).items():
        ret[nm] = recurse(y[nm], item_info) 
    return ret
    
def make_info_for_savemat_recursive(y):
    """
    Creats json info for x, this should enable you to restore
    the oringinal shape of x after scipy.io.savemat/loadmat.

    """
    
    def recurse(x):                
        if isinstance(x, pd_DataFrame):
            return VarInfo(name=None,
                           type="pd_dataframe",
                           dtype=None, ma_fillvalue=None,
                           shape=None,
                           children=[recurse(x[nm]) 
                                     for nm in x.columns])       
        if isinstance(x, pd_Series):            
            if x.dtype.kind.lower() == 'o' and not\
                   np.all([isinstance(xx,(basestring,bool)) for xx in x[x.notnull()]]):
                return VarInfo(name=x.name,
                               type="pd_series",
                               dtype=x.dtype.str, ma_fillvalue=None,
                               shape=x.shape,
                               children=[recurse(xx) 
                                         if not np.isscalar(xx) else None
                                         for xx in x])
            else:
                return VarInfo(name=x.name,
                               type="pd_series",
                               dtype=x.dtype.str,
                               shape=x.shape,ma_fillvalue=None,
                               children=None)
        elif isinstance(x, np.ndarray):
            if x.dtype.kind.lower() == 'o'and not\
                   np.all([isinstance(xx,(basestring,bool, float, long, complex, int))for xx in x]):
                return VarInfo(name=None,
                               type="nd_array",
                               dtype=x.dtype.str,
                               shape=x.shape,
                               ma_fillvalue=x.fill_value if isinstance(x, np.ma.MaskedArray) else None,
                               children=[recurse(xx) 
                                         if not np.isscalar(xx) else None
                                         for xx in x])
            else:
                return VarInfo(name=None,
                               type="nd_array",
                               dtype=x.dtype.str,
                               shape=x.shape,
                               ma_fillvalue=x.fill_value if isinstance(x, np.ma.MaskedArray) else None,
                               children=None)
        elif isinstance(x, (basestring, int, float, long, complex)):
            return None
        elif isinstance(x, (tuple,list)):
            return VarInfo(name=None,
                           type="tuple" if isinstance(x, tuple) else "list",
                               dtype=None, ma_fillvalue=None,
                               shape=len(x),
                               children=[recurse(xx) 
                                         if not np.isscalar(xx) else None
                                         for xx in x])
        else:
            return VarInfo(name=None, type="other", shape=None, children=None)
    
    if not isinstance(y, dict):
        raise TypeError("expected a dict")
    info = {nm: recurse(val) for nm, val in y.items()}
    return json.dumps(info)
    
    
def safe_for_savemat_recursive(x):
    """
    returns True if x, recursively, consists only of the following types:
        basestring, int, long, float, complex, bool, tuple, list, ndarray
        
    Intended for use in conjunction with scipy.io.savemat.

    There is scope for a lot more complicated things to happen, but this
    is what we have for now.
    """
    if isinstance(x, pd_Series):
        x = x[x.notnull()]
        if x.dtype.kind.lower() == 'o':
            return all(safe_for_savemat_recursive(xx) for xx in x)
        else:
            return True  
    elif isinstance(x, np.ndarray):            
        if x.dtype.kind.lower() == 'o':
            return all(safe_for_savemat_recursive(xx) for xx in x)
        else:
            return True
    elif isinstance(x, (basestring, int, float, long, complex)):
        return True
    elif isinstance(x, (tuple,list)):
        return all(safe_for_savemat_recursive(xx) for xx in x)
    else:
        return False


